---
title: "手搓PE32可执行文件"
date: 2024-05-08
category: [basic]
tags: [Format]
img_path: /assets/images/
---

本项目通过手动创建一个简单的exe文件，介绍PE32可执行文件的基本结构。作为入门级别的教程，本文尽可能把需要的前置知识将到最低。其他必要的知识在构建文件的时候讲解。

## 一、项目目标：手动创建简单的PE.exe程序。

功能：弹出一个如下图的对话框（图）

![messagebox]({{ page.name | remove: '.md' }}/messagebox.png)

## 二、基础知识

### 在开始正式创建PE文件之前，默认操作者掌握以下概念（不懂的，可以自行学习，不难）：

* 懂得二进制、十进制、十六进制的表示、计算和转换
* 理解计算机中 bit 和 byte 的概念、组织方式和表示。
* 理解BYTE、WORD、DWORD的概念。
* 掌握 little ending 规范。
* 了解 ASCII 编码和 C 字符串规则。
* 学习过C语言，知道struct结构的尤佳，但不强求。
* 会使用至少一种二进制编辑工具，推荐 ImHex，易上手开源无费用。

### 基础知识 1：进程虚拟地址空间

Widnows中运行一个程序，系统会首先为这个程序创建一个“进程”。进程是程序运行的容器，包含程序运行所需要的各种资源。<br>我们知道程序只有加载到内存才能运行，磁盘上的exe程序加载到内存哪里呢？<br>与我们想象的直接加载到计算机的物理内存不同，操作系统通过“进程”容器给程序提供了一个叫做“虚拟内存地址空间”的东西。磁盘上的exe文件是加载到这个“虚拟内存空间”中的。现代操作系统这么设计的主要目的就是屏蔽操作物理内存的底层细节，让程序员开发的程序面对一个一致的，完整的运行空间。<br>以手动创建的PE.exe为例，其运行时的虚拟内存空间环境大致如下图：

![]({{ page.name | remove: '.md' }}/memory_layout.drawio.png)

> 由于栈是基于线程的，为了让本项目涉及到的知识最简单，这里不做介绍。

### 基础知识 2：内存页和物理内存映射

现代操作系统都是多任务操作系统，可以同时运行很多进程。根据上面介绍的，每一个32位进程都有 4G 的虚拟内存空间，显然我们的计算机物理内存是不够的。通过观察上面的PE.exe虚拟内存分布，可以发现绝大多数虚拟内存是用不上的。而系统DLL其实每一个进程都要用到。所以操作系统巧妙的将虚拟内存“裁减”成一块一块同样大小的内存片，同时把物理内存也“裁减”成同样大小的内存片。只有需要使用的虚拟内存片，操作系统才会将其映射到实际的物理内存片上。这种机制可以轻松实现内存共享，比如系统DLL的物理内存片，可以映射到所有进程的虚拟内存空间中。如下图所示：

![memory_map.drawio]({{ page.name | remove: '.md' }}/memory_map.drawio.png)

“裁减”的内存片的大小很有讲究。裁小了，映射的开销就会增大，最终会得不偿失；裁大了，又会造成许多浪费。现代操作系统根据计算机一般配备的物理内存大小，普遍选用 4KB（4096） 字节大小的内存分片。

### 基础知识 3：PE32可执行文件基本结构

一个典型的exe可执行程序一般包含：

* 文件头：PE32文件头是多个结构的组合
* .code 节：包含用户代码编译后的二进制指令流
* .data 节：包含代码运行前需要预初始化的数据，例如全局变量等
* .idata 节：一般包含程序运行需要用到的系统函数等的导入表。

可以参考“基础知识 4”里面的图。本项目按照这种结构手动构建PE.exe。

### 基础知识 4：从磁盘 File 到内存 Image

将可执行程序从磁盘文件被加载到内存的程序，一般称为`Loader`。这个过程中`Loader`会做许多工作，十分复杂。就理解这个项目来说，需要了解以下两项：

> PE.exe在磁盘上的时候我们称为可执行文件，但被加载到内存时，我们将其称为Image。

1、程序并不是原封不动拷贝的，而是有个“拉伸”过程。

![file2image.drawio]({{ page.name | remove: '.md' }}/file2image.drawio.png)

图中可以看出`section`在文件中和加载到虚拟内存中，起始地址对齐的位置不同。为什么是512和4096呢？因为传统磁盘一个扇区是512个字节，而前面讲过内存页的大小是 4KB，也就是4096个字节。显然磁盘文件保存形式更紧凑，节约存储空间。而内存模式，因为是以内存页的形式将虚拟内存映射到物理内存，用不到的虚拟内存不映射到物理内存，所以也不存在“浪费”一说。

由于这种加载时候的“拉伸”过程存在，程序中变量/字段的相对位置（相对于文件/内存Image起始位置）会不一样。所以产生FOA和RVA的概念。

* FOA：File Offset Address，字段在文件中，相对文件起始位置的偏移量。我们手动创建PE.exe时就需要使用这个偏移量来定位需要编辑的字段。
* RVA：Relative Virtual Address，字段在内存Image中，相对Image起始位置的偏移量。编辑字段值时需要特别注意。

2、根据导入表加载相应的DLL，并将实际的函数虚拟地址更新到导入表的地址表中。

导入表是一个新概念，这里只简单提一下，不理解没关系。后面讲到 `.idata`节的时候，会详细介绍这一部分。这是理解windows可执行文件格式中很重要的内容，也是本项目知识点中理解起来最困难的部分。不过不要害怕，只要认真学习这个简化到及至的例子，其实也就那么回事。

## 三、创建PE32可执行文件框架

按照“基础知识 3”介绍的典型PE32可执行文件基本结构，准备创建的PE.exe文件，分为4个部分：文件头、.code 节、.data 节、.idata 节。

由于PE.exe功能简单，本项目设定每个部分大小都是512字节。

使用二进制编辑工具（如imHex），创建一个`512*4=2048`个字节，值全为0的二进制文件，保存为`PE.exe`。

![rawbinfile]({{ page.name | remove: '.md' }}/rawbinfile.png)
